
import logging
from collections import defaultdict
from odoo import api, fields, models, _
from odoo.exceptions import ValidationError, UserError
import re

_logger = logging.getLogger(__name__)

class MrpPedidoOriginal(models.Model):
    _name = "mrp.pedido.original"
    _description = "Cat谩logo de 'Pedido original' (PED-...)"
    _order = "name"

    name = fields.Char(string='C贸digo maestro', required=False, copy=False, index=True, readonly=True)

    _sql_constraints = [
        ("pedido_original_unique", "unique(name)", "El 'Pedido original' ya existe.")
    ]

    @api.constrains("name")
    def _check_prefix(self):
        for rec in self:
            if rec.name and not rec.name.startswith("PED-"):
                raise ValidationError(_("El 'Pedido original' debe iniciar con 'PED-'."))

class MrpMasterOrder(models.Model):

    def action_mark_tab_done(self):
        """Placeholder: marcar pesta帽a como hecha (sin l贸gica por ahora)."""
        self.ensure_one()
        return True

    def action_generate_warehouse_delivery(self):
        """Generar entrega a bodega con los productos de la pesta帽a de Inspecci贸n Final."""
        self.ensure_one()
        
        # Obtener todos los tipos de operaci贸n disponibles para depuraci贸n
        all_picking_types = self.env['stock.picking.type'].search([])
        debug_info = ['=== TIPOS DE OPERACIN DISPONIBLES ===']
        for pt in all_picking_types:
            debug_info.append(f'ID: {pt.id}, Nombre: {pt.name}, C贸digo: {pt.code}, Secuencia: {pt.sequence_code}')
        _logger.info('\n'.join(debug_info))
        
        # Buscar el tipo de operaci贸n espec铆fico
        picking_type_name = 'CRILAMYT: Almacenar Producto Terminado'
        debug_msg = f'Buscando tipo de operaci贸n: {picking_type_name}'
        _logger.info(debug_msg)
        
        # Intentar con b煤squeda exacta
        picking_type = self.env['stock.picking.type'].search([
            ('name', '=', picking_type_name)
        ], limit=1)
        
        # Si no se encuentra, intentar con b煤squeda que ignore may煤sculas/min煤sculas
        if not picking_type:
            debug_msg = 'No se encontr贸 con b煤squeda exacta, intentando con b煤squeda que ignora may煤sculas/min煤sculas'
            _logger.info(debug_msg)
            picking_type = self.env['stock.picking.type'].search([
                ('name', 'ilike', 'almacenar producto terminado')
            ], limit=1)
        
        # Si a煤n no se encuentra, intentar con el m茅todo anterior para mantener compatibilidad
        if not picking_type:
            debug_msg = 'No se encontr贸 con b煤squeda flexible, intentando con b煤squeda por c贸digo interno'
            _logger.info(debug_msg)
            picking_type = self.env['stock.picking.type'].search([
                ('code', '=', 'internal'),
                ('sequence_code', '=', 'INT')
            ], limit=1)
        
        if not picking_type:
            # Mostrar los tipos disponibles en el mensaje de error
            available_types = '\n'.join([f'- {pt.name} (ID: {pt.id})' for pt in all_picking_types])
            raise UserError(_('''No se encontr贸 el tipo de operaci贸n para almacenar producto terminado 1.

Tipos de operaci贸n disponibles:
{}'''.format(available_types)))
        
        # Obtener ubicaci贸n de origen (ubicaci贸n de producci贸n) y destino (almac茅n de productos terminados)
        # Primero intentar con la referencia est谩ndar
        location_src_id = self.env.ref('stock.stock_location_production', raise_if_not_found=False)
        
        # Si no se encuentra o no es la correcta, buscar expl铆citamente 'Production' en 'Virtual Locations'
        if not location_src_id or 'production' not in (location_src_id.complete_name or '').lower():
            _logger.info('Ubicaci贸n de producci贸n est谩ndar no encontrada, buscando manualmente...')
            virtual_locations = self.env['stock.location'].search([
                ('complete_name', 'ilike', 'Virtual Locations/Production')
            ])
            
            if virtual_locations:
                location_src_id = virtual_locations[0]
                _logger.info(f'Ubicaci贸n de producci贸n encontrada manualmente: {location_src_id.complete_name}')
        
        location_dest_id = picking_type.default_location_dest_id
        
        # Log detailed information about locations for debugging
        _logger.info('=== UBICACIONES ===')
        _logger.info(f'Ubicaci贸n de origen: {location_src_id.complete_name if location_src_id else "No encontrada"}')
        _logger.info(f'Ubicaci贸n de destino: {location_dest_id.complete_name if location_dest_id else "No encontrada"}')
        
        if not location_src_id:
            # Intentar encontrar un almac茅n de manufactura
            almacen_manufactura = self.env['stock.warehouse'].search([
                ('manufacture_to_resupply', '=', True)
            ], limit=1)
            
            if almacen_manufactura:
                location_src_id = almacen_manufactura.lot_stock_id or almacen_manufactura.view_location_id
                _logger.info(f'Usando ubicaci贸n del almac茅n de manufactura: {location_src_id.display_name if location_src_id else "No encontrada"}')
            else:
                _logger.warning('No se encontr贸 un almac茅n configurado para manufactura (manufacture_to_resupply=True)')
                # Si no hay almac茅n de manufactura, intentar con el almac茅n por defecto de la compa帽铆a
                almacen_default = self.env['stock.warehouse'].search([], limit=1)
                if almacen_default:
                    location_src_id = almacen_default.lot_stock_id or almacen_default.view_location_id
                    _logger.info(f'Usando ubicaci贸n del almac茅n por defecto: {location_src_id.display_name if location_src_id else "No encontrada"}')
        
        if not location_src_id or not location_dest_id:
            error_msg = 'No se pudieron determinar las ubicaciones de origen y/o destino.\n\n'
            if not location_src_id:
                error_msg += '- No se pudo determinar la ubicaci贸n de origen. Verifique que exista la ubicaci贸n de producci贸n (stock.stock_location_production).\n'
            if not location_dest_id:
                error_msg += '- No se pudo determinar la ubicaci贸n de destino. Verifique que el tipo de operaci贸n tenga configurada una ubicaci贸n de destino por defecto.\n'
            error_msg += '\nDetalles del tipo de operaci贸n seleccionado:\n'
            if picking_type:
                error_msg += f'ID: {picking_type.id}\n'
                if hasattr(picking_type, 'default_location_src_id') and picking_type.default_location_src_id:
                    error_msg += f'Ubicaci贸n de origen por defecto: {picking_type.default_location_src_id.display_name} (ID: {picking_type.default_location_src_id.id})\n'
                error_msg += f'Ubicaci贸n de destino: {location_dest_id.display_name if location_dest_id else "No definida"} (ID: {location_dest_id.id if location_dest_id else "N/A"})\n'
                if hasattr(picking_type, 'warehouse_id') and picking_type.warehouse_id:
                    error_msg += f'Almac茅n: {picking_type.warehouse_id.name} (ID: {picking_type.warehouse_id.id})\n'
            raise UserError(_(error_msg))
        
        # Obtener l铆neas de la pesta帽a de Inspecci贸n Final con cantidad a entregar > 0
        lines_to_deliver = self.line_ids_inspeccion_final.filtered(
            lambda l: l.qty_to_deliver and l.qty_to_deliver > 0 and l.product_id
        )
        
        if not lines_to_deliver:
            raise UserError(_('No hay productos para entregar. Por favor, verifique las cantidades a entregar.'))
        
        # Crear el picking
        picking_vals = {
            'picking_type_id': picking_type.id,
            'location_id': location_src_id.id,
            'location_dest_id': location_dest_id.id,
            'origin': self.name,
            'scheduled_date': fields.Datetime.now(),
            'move_ids': [],
        }
        
        # Agregar l铆neas al picking
        move_vals_list = []
        for line in lines_to_deliver:
            move_vals = {
                'name': line.product_id.name,
                'product_id': line.product_id.id,
                'product_uom_qty': line.qty_to_deliver,
                'product_uom': line.uom_id.id,
                'location_id': location_src_id.id,
                'location_dest_id': location_dest_id.id,
                'picking_type_id': picking_type.id,
                'origin': self.name,
            }
            picking_vals['move_ids'].append((0, 0, move_vals))
            move_vals_list.append((line.qty_to_deliver, line.uom_id.id, line.product_id.id))
        
        # Crear el picking
        picking = self.env['stock.picking'].create(picking_vals)
        
        # Confirmar el picking para que se generen las l铆neas de movimiento
        picking.action_confirm()
        
        # Actualizar la cantidad realizada en las l铆neas de movimiento
        for move_line in picking.move_line_ids:
            for qty_done, uom_id, product_id in move_vals_list:
                if move_line.product_id.id == product_id and move_line.product_uom_id.id == uom_id:
                    move_line.qty_done = qty_done
        
        # Confirmar el picking autom谩ticamente
        picking.action_confirm()
        
        # Retornar acci贸n para abrir el picking creado
        return {
            'name': _('Entrega a Bodega'),
            'view_mode': 'form',
            'res_model': 'stock.picking',
            'res_id': picking.id,
            'type': 'ir.actions.act_window',
            'target': 'current',
        }


    def copy(self, default=None):
        """Duplicado seguro: limpia nombre/estado y siempre retorna el nuevo registro."""
        self.ensure_one()
        default = dict(default or {})
        # Nombre temporal para pasar validaciones durante la creaci贸n; se limpia luego.
        default.setdefault('name', 'TEMP-DUP')
        default.setdefault('state', 'draft')
        if 'production_ids' in self._fields:
            default['production_ids'] = [(5, 0, 0)]
        new = super(MrpMasterOrder, self).copy(default)
        # Forzar duplicado de l铆neas de productos si no vinieron
        try:
            if not new.line_ids and self.line_ids:
                commands = []
                for l in self.line_ids:
                    vals = {'product_id': l.product_id.id,
                            'product_qty': getattr(l, 'product_qty', 1.0),
                            'uom_id': l.uom_id.id if getattr(l, 'uom_id', False) else False,
                            'pedido_original_id': l.pedido_original_id.id if getattr(l, 'pedido_original_id', False) else False,
                            'note': l.note or False,
                            'state': 'draft'}
                    commands.append((0, 0, vals))
                if commands:
                    new.write({'line_ids': commands})
            # Limpieza posterior: nombre vac铆o y campos transitorios de l铆neas
            new.write({'name': False})
            for line in new.line_ids:
                vals = {}
                if 'production_id' in line._fields:
                    vals['production_id'] = False
                if vals:
                    line.write(vals)
        except Exception:
            pass
        return new

    def _assign_code_on_confirm(self):
        """Asignar el c贸digo maestro s贸lo al confirmar (si est谩 vac铆o) usando el prefijo del Tipo."""
        for rec in self:
            if rec.name:
                continue
            try:
                if rec.stage_type == 'opt' and hasattr(rec.type_id, 'get_opt_formatted_code'):
                    rec.name = rec.type_id.get_opt_formatted_code()
                else:
                    rec.name = rec.type_id.get_formatted_code()
            except Exception:
                # Fallback defensivo
                padding = int(self.env['ir.config_parameter'].sudo().get_param('mrp_master.code_padding', default='6'))
                if rec.stage_type == 'opt':
                    pref = (getattr(rec.type_id, 'opt_prefix', False) or rec.type_id.prefix or 'OPT').strip()
                else:
                    pref = (rec.type_id.prefix or 'OC').strip()
                if not pref.endswith('-'):
                    pref += '-'
                seq_val = (rec.type_id.opt_next_number if rec.stage_type == 'opt' else rec.type_id.next_number) or 1
                rec.name = f"{pref}{str(seq_val).zfill(padding)}"

    _name = "mrp.master.order"
    _description = "Orden Maestra de Producci贸n"
    _inherit = ["mail.thread", "mail.activity.mixin"]
    _order = "id desc"

    state = fields.Selection([
        ("draft", "Borrador"),
        ("confirmed", "Confirmada"),
        ("done", "Hecha"),
        ("cancel", "Cancelada")
    ], string="Estado", default="draft", tracking=True)

    type_id = fields.Many2one("mrp.master.type", "Tipo", required=True, tracking=True)
    name = fields.Char("C贸digo maestro", required=False, copy=False, index=True, tracking=True)
    stage_type = fields.Selection([
        ('curvado_pvb', 'Curvado / PVB'),
        ('opt', 'Producto Terminado (OPT)'),
    ], string="Etapa", default="curvado_pvb", required=True, tracking=True)
    is_curvado_stage = fields.Boolean(string="Es etapa Curvado/PVB", compute="_compute_stage_flags", store=True)
    is_opt_stage = fields.Boolean(string="Es etapa OPT", compute="_compute_stage_flags", store=True)
    source_master_order_id = fields.Many2one(
        "mrp.master.order",
        string="Orden origen (Curv/PVB)",
        domain=[('stage_type', '=', 'curvado_pvb')],
        help="Orden maestra de Curvado/PVB usada como referencia para este OPT."
    )
    date_planned = fields.Datetime("Fecha planificada", default=fields.Datetime.now, required=True, tracking=True)
    location_dest_id = fields.Many2one("stock.location", compute="_compute_location_dest",
                                       string="Ubicaci屈n destino (tomada del Tipo)", store=True, readonly=True)
    company_id = fields.Many2one("res.company", default=lambda self: self.env.company, readonly=True)

    line_ids = fields.One2many("mrp.master.order.line", "master_id", string="L铆neas")
    production_ids = fields.One2many("mrp.production", "master_order_id", string="rdenes de fabricaci贸n generadas", readonly=True)
    production_count = fields.Integer("# MOs", compute="_compute_production_count")

    _sql_constraints = [
        ("name_unique", "unique(name)", "El c贸digo de la Orden Maestra ya existe.")
    ]

    @api.depends('stage_type')
    def _compute_stage_flags(self):
        for rec in self:
            rec.is_curvado_stage = rec.stage_type == 'curvado_pvb' or not rec.stage_type
            rec.is_opt_stage = rec.stage_type == 'opt'

    @api.depends('stage_type', 'type_id', 'type_id.location_dest_id', 'type_id.location_dest_opt_id')
    def _compute_location_dest(self):
        for rec in self:
            if rec.stage_type == 'opt':
                rec.location_dest_id = rec.type_id.location_dest_opt_id or rec.type_id.location_dest_id
            else:
                rec.location_dest_id = rec.type_id.location_dest_id

    @api.model_create_multi
    def create(self, vals_list):
        # No asignar c贸digo al crear; se asigna al confirmar
        return super().create(vals_list)

    def write(self, vals):
        # No reasignar c贸digo al cambiar el tipo; se asigna al confirmar
        return super().write(vals)

    @api.onchange('type_id')
    def _onchange_type_id(self):
        # Ya no sugerimos c贸digo en borrador
        return

    @api.constrains("name")
    def _check_name(self):
        for rec in self:
            if rec.name and '-' not in rec.name:
                raise ValidationError(_('El c贸digo maestro debe tener un guion. Ej.: OCP-000123.'))

    def _compute_production_count(self):
        for rec in self:
            rec.production_count = self.env["mrp.production"].search_count([("origin", "=", rec.name)])

    def action_view_productions(self):
        self.ensure_one()
        action = self.env.ref("mrp.mrp_production_action").sudo().read()[0]
        action["domain"] = [("origin", "=", self.name)]
        action["context"] = {"search_default_groupby_product": 1}
        return action


    def action_view_workorders(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('rdenes de Trabajo'),
            'res_model': 'mrp.workorder',
            'view_mode': 'tree,form,calendar,pivot,graph',
            'domain': [('production_id.master_order_id', '=', self.id)],
            'context': {'search_default_groupby_production': 1},
        }

    def action_open_print_wizard(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Imprimir'),
            'res_model': 'mrp.master.print.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_master_id': self.id,
                'default_stage_type': self.stage_type,
            }
        }

    # Helpers para botones por pesta帽a
    def _get_lines_by_tab(self, rec, tab_key):
        mapping = {
            'hp_t1': getattr(rec, 'line_ids_hp_t1', self.env['mrp.master.order.line']),
            'hp_t2': getattr(rec, 'line_ids_hp_t2', self.env['mrp.master.order.line']),
            'hg_t1': getattr(rec, 'line_ids_hg_t1', self.env['mrp.master.order.line']),
            'hg_t2': getattr(rec, 'line_ids_hg_t2', self.env['mrp.master.order.line']),
            'corte': getattr(rec, 'line_ids_corte', self.env['mrp.master.order.line']),
            'ensamblado': getattr(rec, 'line_ids_ensamblado', self.env['mrp.master.order.line']),
            'prevaciado': getattr(rec, 'line_ids_prevaciado', self.env['mrp.master.order.line']),
            'inspeccion_final': getattr(rec, 'line_ids_inspeccion_final', self.env['mrp.master.order.line']),
        }
        return mapping.get(tab_key, rec.line_ids)

    def _get_stage_lines(self, stage_type=None):
        """Return the lines that belong to the requested stage."""
        stage = stage_type or self.stage_type or 'curvado_pvb'
        hp_t1 = getattr(self, 'line_ids_hp_t1', self.env['mrp.master.order.line'])
        hp_t2 = getattr(self, 'line_ids_hp_t2', self.env['mrp.master.order.line'])
        hg_t1 = getattr(self, 'line_ids_hg_t1', self.env['mrp.master.order.line'])
        hg_t2 = getattr(self, 'line_ids_hg_t2', self.env['mrp.master.order.line'])
        corte = getattr(self, 'line_ids_corte', self.env['mrp.master.order.line'])
        ens = getattr(self, 'line_ids_ensamblado', self.env['mrp.master.order.line'])
        prev = getattr(self, 'line_ids_prevaciado', self.env['mrp.master.order.line'])
        insp = getattr(self, 'line_ids_inspeccion_final', self.env['mrp.master.order.line'])
        if stage == 'opt':
            lines = (ens | prev | insp)
            return lines if lines else self.line_ids
        lines = (hp_t1 | hp_t2 | hg_t1 | hg_t2 | corte)
        return lines if lines else self.line_ids

    def _get_lines_for_generation(self):
        """Return the lines to use when generating MOs for this order."""
        self.ensure_one()
        stage = self.stage_type or 'curvado_pvb'
        if stage == 'opt':
            ens = getattr(self, 'line_ids_ensamblado', self.env['mrp.master.order.line'])
            prev = getattr(self, 'line_ids_prevaciado', self.env['mrp.master.order.line'])
            insp = getattr(self, 'line_ids_inspeccion_final', self.env['mrp.master.order.line'])
            lines = ens | prev | insp
            return lines if lines else self.line_ids
        hp_t1 = getattr(self, 'line_ids_hp_t1', self.env['mrp.master.order.line'])
        hp_t2 = getattr(self, 'line_ids_hp_t2', self.env['mrp.master.order.line'])
        hg_t1 = getattr(self, 'line_ids_hg_t1', self.env['mrp.master.order.line'])
        hg_t2 = getattr(self, 'line_ids_hg_t2', self.env['mrp.master.order.line'])
        corte = getattr(self, 'line_ids_corte', self.env['mrp.master.order.line'])
        lines = hp_t1 | hp_t2 | hg_t1 | hg_t2 | corte
        return lines if lines else self.line_ids

    def _compute_arrastre_map(self, stage_type, product_ids):
        """Compute arrastre por producto tomando 贸rdenes previas de la misma etapa."""
        self.ensure_one()
        if not product_ids:
            return {}
        domain = [
            ('stage_type', '=', stage_type),
            ('state', '!=', 'cancel'),
            ('id', '!=', self.id),
        ]
        if self.date_planned:
            domain.append(('date_planned', '<', self.date_planned))
        previous_orders = self.search(domain)
        planned = defaultdict(float)
        real = defaultdict(float)
        product_set = set(product_ids)
        for order in previous_orders:
            lines = order._get_stage_lines(stage_type)
            for line in lines.filtered(lambda l: l.product_id and l.product_id.id in product_set):
                planned[line.product_id.id] += (line.product_qty or 0.0)
                real[line.product_id.id] += line.cantidad_real or 0.0
        result = {}
        for pid, qty in planned.items():
            diff = qty - real.get(pid, 0.0)
            if diff > 0:
                result[pid] = diff
        return result

    def _apply_arrastre_to_lines(self, lines, arrastre_map):
        """Assign arrastre to one line per product to avoid duplicating carry-over."""
        if not lines:
            return
        remaining = dict(arrastre_map or {})
        for line in lines.sorted(key=lambda l: l.id or 0):
            pid = line.product_id.id if line.product_id else False
            if not pid:
                line.arrastre_qty = 0.0
                continue
            arr = remaining.get(pid, 0.0)
            line.arrastre_qty = arr if arr else 0.0
            if arr:
                remaining[pid] = 0.0
            elif pid not in arrastre_map:
                line.arrastre_qty = 0.0

    def action_view_mos_tab(self):
        self.ensure_one()
        tab = self.env.context.get('mrp_tab')
        lines = self._get_lines_by_tab(self, tab)
        prod_ids = lines.mapped('production_id').ids
        action = self.env.ref("mrp.mrp_production_action").sudo().read()[0]
        action["domain"] = [("id", "in", prod_ids)] if prod_ids else [("id", "=", 0)]
        action["context"] = {"search_default_groupby_product": 1}
        return action

    def action_view_wos_tab(self):
        self.ensure_one()
        tab = self.env.context.get('mrp_tab')
        lines = self._get_lines_by_tab(self, tab)
        prod_ids = lines.mapped('production_id').ids
        return {
            'type': 'ir.actions.act_window',
            'name': _('rdenes de Trabajo'),
            'res_model': 'mrp.workorder',
            'view_mode': 'tree,form,calendar,pivot,graph',
            'domain': [('production_id', 'in', prod_ids if prod_ids else [0])],
            'context': {'search_default_groupby_production': 1},
        }
    def _increment_type_sequence(self):
        for rec in self:
            t = rec.type_id
            if rec.stage_type == 'opt' and 'opt_next_number' in t._fields:
                t.sudo().write({"opt_next_number": t.opt_next_number + 1})
            else:
                t.sudo().write({"next_number": t.next_number + 1})

    def _find_bom(self, product, company_id):
        Bom = self.env["mrp.bom"]
        try:
            bom = Bom._bom_find(product, company_id)
            if bom:
                return bom
        except TypeError:
            pass
        except Exception:
            pass
        bom = Bom.search([("product_id", "=", product.id), ("company_id", "in", [company_id, False])], limit=1)
        if not bom and product.product_tmpl_id:
            bom = Bom.search([("product_tmpl_id", "=", product.product_tmpl_id.id), ("company_id", "in", [company_id, False])], limit=1)
        return bom

    def _generate_mo_for_line(self, rec, line, index):
        bom = self._find_bom(line.product_id, rec.company_id.id)
        if not bom:
            raise ValidationError(_("L铆nea %s: El producto %s no tiene LdM.") % (index, line.product_id.display_name))
        if not line.pedido_original_id:
            raise ValidationError(_("L铆nea %s: Debe especificar un 'Pedido original' (PED-...).") % index)
        qty_to_use = getattr(line, 'qty_total', False) or line.product_qty
        vals = {
            "product_id": line.product_id.id,
            "product_qty": qty_to_use,
            "product_uom_id": line.uom_id.id,
            "company_id": rec.company_id.id,
            "origin": rec.name,
            "date_start": rec.date_planned,
        }
        if rec.location_dest_id:
            vals["location_dest_id"] = rec.location_dest_id.id
        mo = self.env["mrp.production"].create(vals)
        if "x_studio_pedido_original" in mo._fields:
            mo.write({"x_studio_pedido_original": line.pedido_original_id.name})
        mo.master_order_id = rec.id
        AutoConfirm = self.env["ir.config_parameter"].sudo().get_param("mrp_master.auto_confirm_mo", "True") == "True"
        if AutoConfirm:
            mo.action_confirm()
        line.state = "generated"
        line.production_id = mo.id
        return mo

    def button_confirm(self):
        # Permisos: solo Administrador de Fabricaci贸n o Ajustes pueden confirmar
        user = self.env.user
        if not (user.has_group('mrp.group_mrp_manager') or user.has_group('base.group_system')):
            raise ValidationError(_('No tiene permisos para confirmar.'))
        self._assign_code_on_confirm()
        for rec in self:
            lines = rec._get_lines_for_generation()
            if not lines:
                raise ValidationError(_("Debe agregar al menos una l铆nea."))
            errors = []
            for i, line in enumerate(lines, start=1):
                if line.state == "generated":
                    continue
                try:
                    self._generate_mo_for_line(rec, line, i)
                except Exception as e:
                    errors.append(str(e))
            if errors:
                raise ValidationError("\n".join(errors))
            rec.state = "confirmed"
            rec._increment_type_sequence()
        return True

    def button_generate_pending(self):
        for rec in self:
            lines = rec._get_lines_for_generation()
            pending = lines.filtered(lambda l: l.state != "generated")
            if not pending:
                raise ValidationError(_("No hay l铆neas pendientes por generar."))
            errors = []
            for i, line in enumerate(pending, start=1):
                try:
                    self._generate_mo_for_line(rec, line, i)
                except Exception as e:
                    errors.append(str(e))
            if errors:
                raise ValidationError("\n".join(errors))
        return True


 MrpMasterOrderLine(models.Model):
    _name = "mrp.master.order.line"
    _description = "L铆nea de Orden Maestra de Producci贸n"
    mo_state = fields.Char(string='Estado MO', compute='_compute_mo_state', store=False, readonly=True)
    _order = "id"

    master_id = fields.Many2one("mrp.master.order", string="Orden Maestra", required=False, ondelete="cascade")
    state = fields.Selection([("draft", "Borrador"), ("generated", "Generada")], default="draft", string="Estado", readonly=True, copy=False)

    type_id = fields.Many2one(related="master_id.type_id", string="Tipo (rel)", store=False)
    
    tab = fields.Selection([
        ('t1', 'T1'),
        ('t2', 'T2'),
        ('corte', 'Corte'),
        ('ensamblado', 'Ensamblado')
    ], string='Pesta帽a', default=lambda self: self.env.context.get('default_tab') or 't1', index=True)
    product_id = fields.Many2one("product.product", string="Producto", required=True)

    available_product_ids = fields.Many2many('product.product', string='Productos disponibles', compute='_compute_available_products', store=False)
    display_index = fields.Integer("N掳", compute="_compute_display_index", store=False)

    @api.depends('type_id')
    def _compute_available_products(self):
        Product = self.env['product.product']
        for line in self:
            if line.type_id and line.type_id.categ_id:
                line.available_product_ids = Product.search([('categ_id', 'child_of', line.type_id.categ_id.id)])
            else:
                line.available_product_ids = Product.browse()

    @api.depends(
        'sequence',
        'master_id', 'master_id_hp_t1', 'master_id_hp_t2', 'master_id_hg_t1', 'master_id_hg_t2',
        'master_id_corte', 'master_id_ensamblado', 'master_id_prevaciado', 'master_id_inspeccion_final'
    )
    def _compute_display_index(self):
        """Numerar filas en las grillas de manera consecutiva, independiente del campo sequence."""
        parent_map = {}
        for line in self:
            parent = (
                line.master_id or line.master_id_hp_t1 or line.master_id_hp_t2 or
                line.master_id_hg_t1 or line.master_id_hg_t2 or line.master_id_corte or
                line.master_id_ensamblado or line.master_id_prevaciado or line.master_id_inspeccion_final
            )
            parent_map.setdefault(parent.id if parent else 0, []).append(line)
        for lines in parent_map.values():
            for idx, l in enumerate(sorted(lines, key=lambda r: (r.sequence or 0, r.id or 0)), start=1):
                l.display_index = idx

    product_qty = fields.Float("Cantidad", required=True, default=1.0)
    arrastre_qty = fields.Float("Arrastre", default=0.0, help="Remanente pendiente de 贸rdenes previas.")
    qty_total = fields.Float("Cantidad total", compute='_compute_qty_total', store=True)
    qty_to_deliver = fields.Float("Cantidad a Entregar", compute='_compute_qty_to_deliver', store=True, readonly=False)
    cantidad_real = fields.Float('Cantidad real', compute='_compute_cantidad_real', store=True, readonly=True)
    uom_id = fields.Many2one("uom.uom", string="UdM", related="product_id.uom_id", readonly=False, store=True)
    pedido_original_id = fields.Many2one("mrp.pedido.original", string="Pedido original")
    note = fields.Char("Notas")
    product_code = fields.Char("C贸digo", compute="_compute_product_code", store=False)
    largo = fields.Float("Largo")
    ancho = fields.Float("Ancho")
    scrap_qty = fields.Float("Desechos", default=0.0)
    scrap_reason = fields.Char("Raz贸n de desecho")
    production_id = fields.Many2one("mrp.production", string="MO creada", readonly=True, copy=False)

    @api.depends('product_qty', 'arrastre_qty')
    def _compute_qty_total(self):
        for line in self:
            line.qty_total = (line.product_qty or 0.0) + (line.arrastre_qty or 0.0)

    @api.depends('qty_total')
    def _compute_qty_to_deliver(self):
        for line in self:
            line.qty_to_deliver = line.qty_total

    @api.depends('production_id.workorder_ids.qty_produced',
                 'production_id.workorder_ids.scrap_ids.scrap_qty')
    def _compute_cantidad_real(self):
        # Agrupamos por producci贸n para minimizar consultas a stock.scrap
        productions = self.mapped('production_id').filtered(lambda p: p)
        workorders = productions.workorder_ids
        scrap_by_wo = {}
        if workorders:
            Scrap = self.env['stock.scrap']
            scrap_records = Scrap.search(['|', ('workorder_id', 'in', workorders.ids), ('production_id', 'in', productions.ids)])
            for sc in scrap_records:
                key = sc.workorder_id.id or f"p-{sc.production_id.id}"
                scrap_by_wo[key] = scrap_by_wo.get(key, 0.0) + (getattr(sc, 'scrap_qty', 0.0) or 0.0)
        wo_qty_map = {wo.id: wo.qty_produced or 0.0 for wo in workorders}
        for line in self:
            qty = 0.0
            production = line.production_id
            if production:
                related_wos = production.workorder_ids
                produced = sum(wo_qty_map.get(wo.id, 0.0) for wo in related_wos)
                scrap_total = 0.0
                for wo in related_wos:
                    scrap_total += scrap_by_wo.get(wo.id, 0.0)
                # Incluir scrap asociado directamente a la producci贸n (sin workorder)
                scrap_total += scrap_by_wo.get(f"p-{production.id}", 0.0)
                qty = produced - scrap_total
            # Restar desecho manual de la l铆nea, si existe
            qty -= (line.scrap_qty or 0.0)
            line.cantidad_real = qty if qty > 0 else 0.0

    @api.depends('product_id', 'product_id.default_code')
    def _compute_product_code(self):
        pattern = re.compile(r"-T\d+$")
        for line in self:
            code = (line.product_id.default_code or '').strip()
            if not code:
                line.product_code = False
                continue
            parts = code.split('-')
            if pattern.search(code) and len(parts) >= 2:
                line.product_code = f"{parts[-2]}-{parts[-1]}"
            else:
                line.product_code = parts[-1]

    @api.onchange("type_id")
    def _onchange_type_domain(self):
        domain = {}
        if self.type_id and self.type_id.categ_id:
            domain["product_id"] = [("categ_id", "child_of", self.type_id.categ_id.id)]
        else:
            domain["product_id"] = []
        return {"domain": domain}

    @api.model
    def create(self, vals):
        if not vals.get('tab'):
            vals['tab'] = self.env.context.get('default_tab', 't1')
        return super().create(vals)

    @api.depends('production_id.state')
    def _compute_mo_state(self):
        # Mapeo traducible de estados de mrp.production
        state_map = {
            'draft': _('Borrador'),
            'confirmed': _('Confirmada'),
            'planned': _('Planificada'),
            'progress': _('En progreso'),
            'to_close': _('Por cerrar'),
            'done': _('Hecha'),
            'cancel': _('Cancelada'),
        }
        for rec in self:
            code = rec.production_id.state if getattr(rec, 'production_id', False) and rec.production_id else False
            rec.mo_state = state_map.get(code, code or False)

    @api.model
    def _recompute_cantidad_real_for_productions(self, productions):
        prods = productions.filtered(lambda p: p)
        if not prods:
            return
        lines = self.search([('production_id', 'in', prods.ids)])
        if lines:
            lines._compute_cantidad_real()
    
class MrpProduction(models.Model):
    _inherit = "mrp.production"

    master_order_id = fields.Many2one("mrp.master.order", string="Orden Maestra", index=True, readonly=True)

    def _sync_pedido_original_catalog(self):
        if "x_studio_pedido_original" not in self._fields:
            return
        Pedido = self.env["mrp.pedido.original"].sudo()
        for rec in self:
            name = (getattr(rec, 'x_studio_pedido_original', False) or '').strip()
            if name and name.startswith('PED-'):
                exists = Pedido.search([('name', '=', name)], limit=1)
                if not exists:
                    Pedido.create({'name': name})

    @api.model_create_multi
    def create(self, vals_list):
        recs = super().create(vals_list)
        try:
            recs._sync_pedido_original_catalog()
        except Exception:
            pass
        return recs

    @api.model
    def cron_sync_pedidos_originales_mes(self):
        if "x_studio_pedido_original" not in self._fields:
            return True
        today = fields.Date.context_today(self)
        start = today.replace(day=1)
        # compute next month start
        if start.month == 12:
            next_month_start = start.replace(year=start.year + 1, month=1, day=1)
        else:
            next_month_start = start.replace(month=start.month + 1, day=1)
        domain = [
            ("date_start", ">=", fields.Datetime.to_datetime(start)),
            ("date_start", "<", fields.Datetime.to_datetime(next_month_start)),
            ("x_studio_pedido_original", "ilike", "PED-"),
        ]
        Pedido = self.env["mrp.pedido.original"].sudo()
        mos = self.search(domain)
        names = set()
        for mo in mos:
            name = (getattr(mo, 'x_studio_pedido_original', False) or '').strip()
            if name and name.startswith('PED-'):
                names.add(name)
        if not names:
            return True
        existing = Pedido.search([('name', 'in', list(names))])
        existing_names = set(existing.mapped('name'))
        to_create = [{'name': n} for n in names - existing_names]
        if to_create:
            Pedido.create(to_create)
        return True

    def write(self, vals):
        res = super().write(vals)
        try:
            if 'x_studio_pedido_original' in vals:
                self._sync_pedido_original_catalog()
        except Exception:
            pass
        return res




